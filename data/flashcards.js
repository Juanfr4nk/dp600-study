// DP-600 Flashcards — Key concepts for spaced repetition
const FLASHCARDS = [
    // Domain 1: Preparar Datos
    { id: 1, domain: 1, front: "¿Qué es OneLake?", back: "La capa de almacenamiento unificada de Fabric. Un solo OneLake por tenant. Basado en ADLS Gen2 con protocolo ABFS. Todos los items de Fabric almacenan datos aquí." },
    { id: 2, domain: 1, front: "Lakehouse vs Data Warehouse", back: "**Lakehouse**: datos estructurados + no estructurados, Delta Lake, Spark + SQL endpoint (lectura). **Warehouse**: solo datos estructurados, T-SQL completo (lectura + escritura), vistas/SPs." },
    { id: 3, domain: 1, front: "¿Qué es Delta Lake?", back: "Formato de almacenamiento open source sobre Parquet que añade: transacciones ACID, time travel, schema enforcement/evolution, y operaciones MERGE/UPDATE/DELETE." },
    { id: 4, domain: 1, front: "Shortcuts en Lakehouse", back: "Referencias a datos externos (ADLS Gen2, S3, otros Lakehouses) sin copiar datos. Reducen duplicación y costes. Aparecen como tablas/carpetas locales." },
    { id: 5, domain: 1, front: "Flujos de datos Gen2 vs Canalizaciones", back: "**Dataflows Gen2**: transformación visual con Power Query, para ETL de datos. **Pipelines**: orquestación de actividades (Copy Data, Notebook, Dataflow), con programación, reintentos y dependencias." },
    { id: 6, domain: 1, front: "SQL Analytics Endpoint", back: "Endpoint de solo lectura T-SQL automático en cada Lakehouse. Permite consultar tablas Delta con SQL sin necesidad de un Warehouse separado." },
    { id: 7, domain: 1, front: "OPTIMIZE y VACUUM en Delta", back: "**OPTIMIZE**: compacta archivos pequeños en grandes (mejora lectura). **VACUUM**: elimina archivos obsoletos no referenciados. Ambos necesarios para mantenimiento de tablas grandes." },
    { id: 8, domain: 1, front: "V-Order vs Z-Order", back: "**V-Order**: optimización automática de Fabric para compresión Parquet. **Z-Order**: reorganización física de datos por columnas específicas para acelerar filtros (OPTIMIZE ... ZORDER BY col)." },
    { id: 9, domain: 1, front: "Medallion Architecture", back: "Patrón de capas: **Bronze** (raw/sin procesar) → **Silver** (limpio/validado) → **Gold** (curado/listo para negocio). Fabric lo soporta con múltiples Lakehouses." },
    { id: 10, domain: 1, front: "Eventhouse y KQL", back: "**Eventhouse**: componente Real-Time Intelligence para streaming. **KQL**: Kusto Query Language para consultar datos (sintaxis pipe: Tabla | where x > 5 | summarize count())." },
    { id: 11, domain: 1, front: "Eventstream", back: "Herramienta visual para capturar datos de streaming (Event Hubs, IoT Hub, CDC), transformarlos y enrutarlos a Eventhouse, Lakehouse u otros destinos." },
    { id: 12, domain: 1, front: "COPY INTO vs INSERT INTO", back: "**COPY INTO**: carga masiva optimizada desde archivos externos, alto rendimiento. **INSERT INTO ... SELECT**: inserción fila a fila o por lotes, más lenta para volúmenes grandes." },
    { id: 13, domain: 1, front: "Time Travel en Delta Lake", back: "Consultar datos históricos: SELECT * FROM tabla VERSION AS OF 5 o TIMESTAMP AS OF '2024-01-01'. Útil para auditoría y recuperación de datos." },
    { id: 14, domain: 1, front: "Schema Evolution en Delta", back: "**mergeSchema**: añade nuevas columnas al escribir. **overwriteSchema**: reemplaza el esquema completo. Permite evolucionar tablas sin recrearlas." },
    { id: 15, domain: 1, front: "Operadores KQL esenciales", back: "**where**: filtrar filas. **summarize**: agrupar y agregar. **extend**: añadir columnas calculadas. **project**: seleccionar columnas. **render**: visualizar resultados." },

    // Domain 2: Mantener Solución
    { id: 16, domain: 2, front: "Roles de Workspace", back: "**Admin**: control total, puede eliminar workspace. **Member**: gestiona permisos, publica. **Contributor**: crea/edita contenido. **Viewer**: solo lectura." },
    { id: 17, domain: 2, front: "RLS vs CLS vs OLS", back: "**RLS** (Row-Level): filtra filas con DAX. **CLS** (Column-Level): restringe columnas con GRANT/DENY T-SQL. **OLS** (Object-Level): oculta tablas/columnas enteras en el modelo." },
    { id: 18, domain: 2, front: "Dynamic RLS", back: "Usa USERPRINCIPALNAME() en el filtro DAX del rol para identificar al usuario actual y filtrar contra una tabla de mapeo usuario→datos. Un solo rol sirve para todos los usuarios." },
    { id: 19, domain: 2, front: "Deployment Pipelines", back: "CI/CD para Fabric: 3 etapas (Dev → Test → Prod), cada una asociada a un workspace. Compara cambios, promueve contenido de forma controlada." },
    { id: 20, domain: 2, front: "Sensitivity Labels", back: "Etiquetas de Microsoft Purview (Público, Confidencial, Altamente Confidencial) que clasifican contenido y pueden aplicar cifrado, restricciones de exportación y marcas de agua." },
    { id: 21, domain: 2, front: "Git Integration en Fabric", back: "Conecta workspaces a repos Azure DevOps o GitHub. Habilita control de versiones, branching y colaboración en items de Fabric." },
    { id: 22, domain: 2, front: "Capacity en Fabric", back: "Pool de recursos computacionales (CPU/memoria) con tamaños F2-F2048. Se asigna a workspaces. Define la potencia de procesamiento para todas las cargas de trabajo." },
    { id: 23, domain: 2, front: "Endorsement (Certified/Promoted)", back: "**Promoted**: el autor marca su contenido como recomendado. **Certified**: un admin certifica que el contenido cumple estándares de calidad. Ayuda descubrimiento." },
    { id: 24, domain: 2, front: "Permisos Workspace vs Item", back: "**Workspace**: aplican a todo el contenido (herencia). **Item**: permiten compartir elementos individuales con usuarios sin acceso al workspace completo." },
    { id: 25, domain: 2, front: "Managed Private Endpoints", back: "Conexiones seguras desde Fabric a fuentes Azure por red privada (backbone de Azure). Sin tráfico a internet público. Para cumplimiento y seguridad." },
    { id: 26, domain: 2, front: "Monitoring Hub", back: "Vista centralizada para monitorizar actividades en curso: ejecuciones de pipelines, refrescos de modelos, trabajos Spark. Muestra estado, duración y errores." },
    { id: 27, domain: 2, front: "Organización de Workspaces (best practice)", back: "Separar por dominio de negocio (Ventas, RRHH) + por entorno (Dev/Test/Prod). Facilita governance, seguridad y deployment pipelines." },

    // Domain 3: Modelos Semánticos
    { id: 28, domain: 3, front: "Import vs DirectQuery vs Direct Lake", back: "**Import**: datos en memoria, máximo rendimiento, refresco periódico. **DirectQuery**: consulta en tiempo real al origen, menor rendimiento. **Direct Lake**: lee Delta de OneLake directamente, balance rendimiento/frescura." },
    { id: 29, domain: 3, front: "Star Schema (Esquema en Estrella)", back: "Patrón recomendado: tabla de hechos central (métricas numéricas) rodeada de dimensiones (atributos descriptivos). Optimiza VertiPaq y usabilidad." },
    { id: 30, domain: 3, front: "CALCULATE() en DAX", back: "La función más importante. Evalúa una expresión en un contexto de filtro modificado: CALCULATE(SUM(Ventas[Importe]), Producto[Categoría] = \"Electrónica\"). Modifica el contexto de evaluación." },
    { id: 31, domain: 3, front: "Medida vs Columna Calculada", back: "**Medida**: se calcula en tiempo de consulta según el contexto, no ocupa memoria estática. **Columna Calculada**: se calcula al refrescar, se almacena fila a fila. Preferir medidas siempre que sea posible." },
    { id: 32, domain: 3, front: "Calculation Groups", back: "Objetos que definen transformaciones reutilizables (YTD, PY, Moving Avg) aplicables a cualquier medida dinámicamente. Evitan crear N variaciones de cada medida." },
    { id: 33, domain: 3, front: "Incremental Refresh", back: "Política que divide una tabla en particiones temporales. Solo refresca particiones con datos nuevos/modificados. Reduce tiempo de refresco y carga en el origen." },
    { id: 34, domain: 3, front: "Tabla de Fechas (Date Table)", back: "Dimensión con una fila por día, sin gaps, marcada como Date Table. Requisito para Time Intelligence DAX (TOTALYTD, SAMEPERIODLASTYEAR, DATEADD)." },
    { id: 35, domain: 3, front: "Time Intelligence DAX esenciales", back: "**TOTALYTD**: acumulado año. **SAMEPERIODLASTYEAR/DATEADD(-1,YEAR)**: mismo periodo año anterior. **DATESYTD/DATESMTD**: rangos de fechas. **PARALLELPERIOD**: periodo paralelo." },
    { id: 36, domain: 3, front: "REMOVEFILTERS() / ALL()", back: "Eliminan filtros del contexto actual en CALCULATE. Útil para: % del total = DIVIDE(medida, CALCULATE(medida, REMOVEFILTERS(Dimension))). ALL() también como tabla (VALUES sin filtros)." },
    { id: 37, domain: 3, front: "Cardinalidad en relaciones", back: "**1:N** (one-to-many): la más común, de dimensión a hechos. **1:1**: raro, tablas con misma granularidad. **M:N**: evitar, causa ambigüedad (usar bridge table)." },
    { id: 38, domain: 3, front: "Dirección de filtro cruzado", back: "**Single** (unidireccional): recomendada, de dimensión → hechos. **Both** (bidireccional): usar con precaución, puede causar ambigüedad y menor rendimiento." },
    { id: 39, domain: 3, front: "VertiPaq y compresión", back: "Motor columnar in-memory. Usa Dictionary Encoding + Run-Length Encoding. Columnas de baja cardinalidad se comprimen mejor. Reducir cardinalidad = mejor rendimiento." },
    { id: 40, domain: 3, front: "Direct Lake: Framing", back: "Proceso de tomar una instantánea (snapshot) de archivos Delta para cargar en memoria. Entre framings, el modelo ve datos del snapshot anterior. Trigger: refresco o automático." },
    { id: 41, domain: 3, front: "Composite Model", back: "Modelo que mezcla tablas Import + DirectQuery en el mismo modelo. Permite optimizar: Import para dimensiones (rendimiento), DirectQuery para hechos grandes (frescura)." },
    { id: 42, domain: 3, front: "XMLA Endpoint", back: "Permite gestionar modelos semánticos programáticamente con TMSL (scripts JSON) o TOM (.NET). Crear particiones, refrescar, modificar medidas. Requiere Premium/Fabric." },
    { id: 43, domain: 3, front: "DISTINCTCOUNT vs COUNT vs COUNTROWS", back: "**DISTINCTCOUNT(col)**: valores únicos en una columna. **COUNT(col)**: valores no vacíos. **COUNTA(col)**: no blancos. **COUNTROWS(tabla)**: total de filas de una tabla." },
    { id: 44, domain: 3, front: "DAX Studio", back: "Herramienta gratuita para analizar y optimizar DAX. Server Timings muestra tiempo en Formula Engine vs Storage Engine. VertiPaq Analyzer muestra tamaño y compresión del modelo." },
    { id: 45, domain: 3, front: "Direct Lake Fallback", back: "Cuando Direct Lake no puede servir una consulta desde caché (excede límites, datos no cacheados), hace fallback a DirectQuery contra el SQL endpoint. Rendimiento se degrada." },

    // ─── Comparativas X vs Y (46-58) ───
    { id: 46, domain: 1, front: "Pipeline vs Dataflow Gen2", back: "**Pipeline**: orquestación de actividades (Copy, Notebook, Dataflow, Script), control de flujo (ForEach, If, Until), sin transformación visual. **Dataflow Gen2**: transformación visual con Power Query M, con destino de datos (Lakehouse, Warehouse), sin orquestación." },
    { id: 47, domain: 1, front: "Delta Lake vs Parquet puro", back: "**Delta Lake**: Parquet + _delta_log (transaction log). Añade ACID, time travel, MERGE/UPDATE/DELETE, schema enforcement. **Parquet puro**: solo formato columnar, sin transacciones, sin versionado, operaciones append-only." },
    { id: 48, domain: 2, front: "Capacity vs Workspace", back: "**Capacity**: recurso de computación (F2-F2048) facturado a Azure, compartido entre workspaces. **Workspace**: contenedor lógico de items (Lakehouses, Warehouses, informes), asignado a una Capacity. Múltiples workspaces pueden compartir una Capacity." },
    { id: 49, domain: 1, front: "Query Folding vs Local Processing", back: "**Query Folding**: el motor Power Query traduce los pasos M a queries nativas (SQL) ejecutadas en el origen. **Local**: cuando un paso no se puede plegar, Fabric descarga los datos y los procesa en el motor mashup. Folding = rendimiento, Local = lento." },
    { id: 50, domain: 3, front: "Direct Lake vs Import: cuándo usar cada uno", back: "**Direct Lake**: datos en OneLake (Delta), necesitas frescura sin refresco completo, modelo dentro de guardrails de la SKU. **Import**: datos externos a OneLake, necesitas máximo rendimiento, transformaciones complejas en Power Query, o modelo grande que excede guardrails." },
    { id: 51, domain: 3, front: "Direct Lake vs DirectQuery: diferencias clave", back: "**Direct Lake**: lee Parquet de OneLake en VertiPaq (in-memory), rendimiento cercano a Import. **DirectQuery**: envía SQL al endpoint en cada consulta, sin caché VertiPaq, más lento pero sin límite de tamaño. Direct Lake puede hacer fallback a DirectQuery." },
    { id: 52, domain: 2, front: "CLS vs OLS: cuándo usar cada uno", back: "**CLS** (Column-Level Security): oculta columnas específicas en Warehouse con GRANT/DENY en T-SQL. Usuarios ven la tabla pero no ciertas columnas. **OLS** (Object-Level Security): oculta tablas/columnas enteras en el modelo semántico con roles XMLA. Ni siquiera aparecen en la lista de campos." },
    { id: 53, domain: 1, front: "Lakehouse Files vs Tables", back: "**Files**: almacén no gestionado — cualquier formato (CSV, JSON, images, etc.), sin schema, sin SQL automático. **Tables**: tablas Delta gestionadas — schema definido, visibles desde SQL endpoint, optimizadas con V-Order." },
    { id: 54, domain: 2, front: "Deployment Pipelines vs Git Integration", back: "**Deployment Pipelines**: promueve items entre workspaces (Dev→Test→Prod), sin control de versiones granular. **Git Integration**: versiona cada item como archivo en un repo (Azure DevOps/GitHub), permite branching, PRs, diffs. Se complementan." },
    { id: 55, domain: 1, front: "MERGE vs INSERT en Delta Lake", back: "**MERGE**: operación upsert condicional (WHEN MATCHED → UPDATE, WHEN NOT MATCHED → INSERT). Ideal para SCD, deduplicación. **INSERT**: solo añade filas nuevas. MERGE es más costoso pero evita duplicados." },
    { id: 56, domain: 3, front: "SUM vs SUMX en DAX", back: "**SUM(col)**: suma todos los valores de una columna, simple y rápido. **SUMX(tabla, expresión)**: iterador — recorre cada fila y evalúa una expresión, luego suma. Necesario cuando el cálculo involucra múltiples columnas por fila: SUMX(Ventas, Ventas[Qty] * Ventas[Precio])." },
    { id: 57, domain: 1, front: "Eventhouse vs Lakehouse para streaming", back: "**Eventhouse**: optimizado para alta ingesta de datos de streaming con KQL, retención configurable, ventanas de tiempo. **Lakehouse**: para batch o micro-batch, almacenamiento persistente en Delta, consultas SQL/Spark. Eventhouse para real-time analytics, Lakehouse para análisis histórico." },
    { id: 58, domain: 3, front: "Hybrid Tables vs Composite Models", back: "**Hybrid Tables**: una tabla con particiones Import (histórico) + DirectQuery (datos recientes), usando Incremental Refresh. **Composite Models**: múltiples tablas con modos diferentes (Import + DirectQuery) en el mismo modelo. Hybrid es a nivel de tabla, Composite a nivel de modelo." },

    // ─── Patrones DAX avanzados (59-70) ───
    { id: 59, domain: 3, front: "Patrón VAR/RETURN en DAX", back: "```\nMedida = \nVAR VentasActual = [Total Ventas]\nVAR VentasAnterior = CALCULATE([Total Ventas], SAMEPERIODLASTYEAR(Calendario[Fecha]))\nRETURN\nDIVIDE(VentasActual - VentasAnterior, VentasAnterior)\n```\nVAR mejora legibilidad, evita recálculos, y se evalúa en el contexto donde se define (no donde se usa en RETURN)." },
    { id: 60, domain: 3, front: "CALCULATE con múltiples filtros", back: "CALCULATE(expr, filtro1, filtro2) aplica filtros como AND entre ellos. Cada filtro REEMPLAZA filtros externos sobre la misma columna. Para combinar con OR, usar operador || dentro de un solo filtro o FILTER()." },
    { id: 61, domain: 3, front: "TREATAS en DAX", back: "TREATAS(tabla_virtual, Columna_destino) aplica una tabla como filtro sobre otra columna sin relación física. Útil para conectar tablas sin relación formal: CALCULATE([Medida], TREATAS(VALUES(Tabla1[Col]), Tabla2[Col]))." },
    { id: 62, domain: 3, front: "USERELATIONSHIP en DAX", back: "Activa una relación inactiva dentro de CALCULATE: CALCULATE([Total Ventas], USERELATIONSHIP(Ventas[FechaEnvío], Calendario[Fecha])). Necesario cuando hay múltiples relaciones entre tablas (fecha pedido, fecha envío, fecha pago)." },
    { id: 63, domain: 3, front: "Iteradores DAX: SUMX, AVERAGEX, MINX, MAXX", back: "Recorren una tabla fila a fila evaluando una expresión. **SUMX**(tabla, expr): suma resultados. **AVERAGEX**: promedio. **MINX/MAXX**: mínimo/máximo. La tabla puede ser filtrada: SUMX(FILTER(Ventas, Ventas[Tipo]=\"Online\"), Ventas[Qty]*Ventas[Precio])." },
    { id: 64, domain: 3, front: "SELECTEDVALUE vs HASONEVALUE", back: "**SELECTEDVALUE(col, alt)**: devuelve el valor si hay exactamente uno seleccionado, sino el alternativo. **HASONEVALUE(col)**: devuelve TRUE/FALSE. SELECTEDVALUE es preferido — combina ambos en una función." },
    { id: 65, domain: 3, front: "ALL vs ALLEXCEPT vs ALLSELECTED", back: "**ALL(tabla/col)**: elimina todos los filtros. **ALLEXCEPT(tabla, col1, col2)**: elimina todos los filtros EXCEPTO las columnas indicadas. **ALLSELECTED(tabla/col)**: elimina filtros internos del visual pero respeta slicers externos." },
    { id: 66, domain: 3, front: "Contexto de fila vs Contexto de filtro", back: "**Contexto de fila**: existe en columnas calculadas e iteradores (SUMX), itera fila a fila. **Contexto de filtro**: existe en medidas, define qué filas son visibles. CALCULATE convierte contexto de fila en contexto de filtro (context transition)." },
    { id: 67, domain: 3, front: "SWITCH(TRUE(), ...) en DAX", back: "Patrón para múltiples condiciones: SWITCH(TRUE(), [Ventas] > 1000, \"Alto\", [Ventas] > 500, \"Medio\", \"Bajo\"). Evalúa condiciones en orden y devuelve el primer match. Más legible que IF anidados." },
    { id: 68, domain: 3, front: "Time Intelligence: YTD, QTD, MTD", back: "**TOTALYTD(medida, fechas)**: acumulado desde inicio de año. **TOTALQTD**: acumulado trimestre. **TOTALMTD**: acumulado mes. Equivalentes a CALCULATE(medida, DATESYTD/DATESQTD/DATESMTD(calendario[fecha]))." },
    { id: 69, domain: 3, front: "RANKX en DAX", back: "RANKX(ALL(Productos), [Total Ventas], , DESC, Dense) — rankea cada producto por ventas. Parámetros: tabla de evaluación, expresión, valor, orden (ASC/DESC), tipo de empate (Skip/Dense)." },
    { id: 70, domain: 3, front: "FILTER vs filtro directo en CALCULATE", back: "**Filtro directo**: CALCULATE(expr, Tabla[Col] = \"X\") — eficiente, reemplaza filtro existente. **FILTER**: CALCULATE(expr, FILTER(ALL(Tabla), condición)) — iterador, más flexible pero más lento. Usar FILTER solo cuando necesitas condiciones complejas o acceso a medidas." },

    // ─── Comandos de referencia rápida (71-82) ───
    { id: 71, domain: 1, front: "T-SQL esencial: MERGE", back: "```sql\nMERGE target AS t\nUSING source AS s ON t.id = s.id\nWHEN MATCHED THEN UPDATE SET t.col = s.col\nWHEN NOT MATCHED THEN INSERT (id, col) VALUES (s.id, s.col)\nWHEN NOT MATCHED BY SOURCE THEN DELETE;\n```\nPatrón SCD Type 1 / upsert en Warehouse." },
    { id: 72, domain: 1, front: "T-SQL esencial: Window Functions", back: "```sql\nROW_NUMBER() OVER(PARTITION BY dept ORDER BY salary DESC)\nSUM(amount) OVER(ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\nLAG(col, 1) OVER(ORDER BY date) -- valor anterior\nLEAD(col, 1) OVER(ORDER BY date) -- valor siguiente\n```" },
    { id: 73, domain: 1, front: "T-SQL esencial: CTE y PIVOT", back: "```sql\nWITH cte AS (SELECT ... FROM ... WHERE ...)\nSELECT * FROM cte;\n\nSELECT * FROM tabla\nPIVOT (SUM(valor) FOR mes IN ([Ene],[Feb],[Mar])) AS p;\n```\nCTEs mejoran legibilidad. PIVOT convierte filas en columnas." },
    { id: 74, domain: 1, front: "PySpark esencial: leer y escribir Delta", back: "```python\n# Leer\ndf = spark.read.format('delta').load('Tables/ventas')\n# Escribir\ndf.write.format('delta').mode('overwrite').save('Tables/resultado')\n# Leer como tabla\ndf = spark.sql('SELECT * FROM lakehouse.ventas')\n```" },
    { id: 75, domain: 1, front: "PySpark esencial: transformaciones", back: "```python\nfrom pyspark.sql.functions import col, sum, when\ndf2 = df.filter(col('year') >= 2024)\n        .groupBy('category')\n        .agg(sum('amount').alias('total'))\n        .withColumn('status', when(col('total') > 1000, 'High').otherwise('Low'))\n```" },
    { id: 76, domain: 1, front: "PySpark esencial: joins y deduplicación", back: "```python\n# Join\nresult = df1.join(df2, df1.id == df2.id, 'left')\n# Deduplicar\nfrom pyspark.sql.window import Window\nw = Window.partitionBy('key').orderBy(col('ts').desc())\ndf.withColumn('rn', row_number().over(w)).filter('rn = 1')\n```" },
    { id: 77, domain: 1, front: "Power Query M esencial", back: "```\nlet\n  Source = Sql.Database(\"server\", \"db\"),\n  Filtered = Table.SelectRows(Source, each [Year] >= 2024),\n  Grouped = Table.Group(Filtered, {\"Category\"}, {{\"Total\", each List.Sum([Amount])}}),\n  Typed = Table.TransformColumnTypes(Grouped, {{\"Total\", type number}})\nin Typed\n```" },
    { id: 78, domain: 1, front: "KQL esencial: agregaciones", back: "```\nEventos\n| where timestamp > ago(7d)\n| summarize count() by bin(timestamp, 1h), severity\n| order by timestamp asc\n| render timechart\n```\n**bin()**: agrupa timestamps en intervalos. **ago()**: tiempo relativo. **render**: visualización inline." },
    { id: 79, domain: 1, front: "KQL esencial: joins y operadores", back: "```\nTabla1\n| join kind=inner (Tabla2) on $left.id == $right.id\n| extend DiffDays = datetime_diff('day', col1, col2)\n| project-away columnas_no_deseadas\n| top 100 by score desc\n```\nJoin kinds: inner, leftouter, rightouter, fullouter, anti, semi." },
    { id: 80, domain: 1, front: "SparkSQL esencial en Notebooks", back: "```sql\n%%sql\nCREATE OR REPLACE TABLE silver.clientes AS\nSELECT *, ROW_NUMBER() OVER(PARTITION BY email ORDER BY updated_at DESC) as rn\nFROM bronze.clientes_raw;\n\nDELETE FROM silver.clientes WHERE rn > 1;\n```\nMagic command %%sql para ejecutar SQL en celdas Spark." },
    { id: 81, domain: 1, front: "Delta Lake: MERGE en Spark", back: "```python\nfrom delta.tables import DeltaTable\ndelta_t = DeltaTable.forPath(spark, 'Tables/target')\ndelta_t.alias('t').merge(\n    source_df.alias('s'), 't.id = s.id'\n).whenMatchedUpdateAll()\n .whenNotMatchedInsertAll()\n .execute()\n```" },
    { id: 82, domain: 1, front: "Notebook: magic commands Fabric", back: "**%%sql**: ejecutar SparkSQL. **%%pyspark**: PySpark (default). **%%scala**: Scala. **%pip install lib**: instalar librerías Python. **%run otro_notebook**: ejecutar otro notebook. **%%configure**: configurar sesión Spark (cores, memoria)." },

    // ─── Checklists de mejores prácticas (83-92) ───
    { id: 83, domain: 3, front: "Checklist: Performance de modelos semánticos", back: "1. Usar star schema (evitar snowflake)\n2. Reducir cardinalidad de columnas\n3. Eliminar columnas no usadas\n4. Preferir medidas sobre columnas calculadas\n5. Usar variables (VAR) en DAX complejo\n6. Evitar FILTER() cuando basta un filtro directo\n7. Separar fecha y hora en columnas distintas\n8. Activar V-Order en tablas Delta\n9. Usar Calculation Groups vs duplicar medidas\n10. Revisar con DAX Studio y Best Practices Analyzer" },
    { id: 84, domain: 2, front: "Checklist: Seguridad en Fabric", back: "1. Principio de mínimo privilegio en workspace roles\n2. RLS en todos los modelos multi-tenant\n3. CLS/OLS para datos sensibles (salarios, PII)\n4. Sensitivity labels de Purview aplicadas\n5. Managed Private Endpoints para orígenes Azure\n6. Auditar con Unified Audit Log\n7. No compartir workspaces Pro como alternativa a seguridad\n8. Revisar permisos de item-level sharing\n9. Configurar tenant settings restrictivamente\n10. Endorse contenido certificado" },
    { id: 85, domain: 3, front: "Checklist: Modelado dimensional", back: "1. Una tabla de hechos central con claves foráneas + métricas numéricas\n2. Dimensiones con claves sustitutas (surrogate keys)\n3. Tabla de fechas completa marcada como Date Table\n4. Relaciones 1:N desde dimensión → hechos\n5. Filtro cruzado unidireccional (Single)\n6. Evitar relaciones M:N (usar bridge tables)\n7. No incluir columnas de texto largo en dimensiones\n8. Mover cálculos a medidas DAX, no a columnas origen" },
    { id: 86, domain: 1, front: "Checklist: Mantenimiento Delta Lake", back: "1. Ejecutar OPTIMIZE periódicamente (compactar archivos pequeños)\n2. Configurar VACUUM con retención adecuada (default 7 días)\n3. Aplicar Z-ORDER en columnas frecuentemente filtradas\n4. Habilitar V-Order al escribir desde Fabric\n5. Monitorizar el tamaño del _delta_log (checkpoints automáticos cada 10 commits)\n6. Usar ANALYZE TABLE para actualizar estadísticas\n7. Considerar particionamiento por columnas de baja cardinalidad (fecha, región)" },
    { id: 87, domain: 1, front: "Checklist: Pipeline robusta", back: "1. Configurar reintentos (retry policy) en cada actividad\n2. Parametrizar conexiones y rutas (no hardcodear)\n3. Añadir actividad de logging/notificación en caso de error\n4. Usar ForEach para procesamiento dinámico\n5. Separar ingesta (Copy) de transformación (Notebook/Dataflow)\n6. Configurar timeout adecuado por actividad\n7. Usar triggers (programados, evento, tumbling window)" },
    { id: 88, domain: 2, front: "Checklist: Governance en Fabric", back: "1. Definir data domains por área de negocio\n2. Aplicar endorsement (Promoted/Certified) a items validados\n3. Configurar sensitivity labels obligatorias\n4. Habilitar data lineage y impact analysis\n5. Usar Microsoft Purview para catálogo y clasificación\n6. Documentar items con descripciones en el portal\n7. Revisar métricas de uso en Capacity Metrics App\n8. Establecer naming conventions para workspaces e items" },
    { id: 89, domain: 3, front: "Checklist: Direct Lake optimization", back: "1. Mantener tablas dentro de los guardrails de la SKU (filas, columnas, tamaño)\n2. Ejecutar OPTIMIZE + V-Order en tablas Delta\n3. Minimizar el número de columnas en el modelo\n4. Reducir cardinalidad de columnas de texto\n5. Monitorizar framings y fallbacks a DirectQuery\n6. Configurar framing automático o programado\n7. Evitar columnas calculadas DAX (fuerzan fallback)\n8. No usar Power Query en el modelo Direct Lake" },
    { id: 90, domain: 1, front: "Checklist: Dataflow Gen2 eficiente", back: "1. Maximizar query folding (verificar con indicador visual)\n2. Ordenar pasos para que las operaciones plegables vayan primero\n3. Usar staging intermedio para orígenes lentos\n4. Elegir Replace vs Append según el escenario\n5. No usar transformaciones M sin equivalente SQL (rompen folding)\n6. Configurar data destination en Lakehouse o Warehouse\n7. Combinar con Pipeline para orquestación compleja" },
    { id: 91, domain: 2, front: "Checklist: CI/CD con Git Integration", back: "1. Conectar workspace Dev a repo Git (Azure DevOps o GitHub)\n2. Usar branching (feature branches → main)\n3. Validar cambios con PR reviews\n4. Usar Deployment Pipelines para promover Dev→Test→Prod\n5. Configurar Deployment Rules para sustituir conexiones por entorno\n6. No modificar directamente en workspace Prod\n7. Documentar cambios en commits descriptivos" },
    { id: 92, domain: 1, front: "Checklist: Medallion Architecture", back: "1. **Bronze**: raw inmutable, mismo formato del origen, append-only\n2. **Silver**: limpieza, deduplicación, tipado, joins entre fuentes\n3. **Gold**: agregaciones de negocio, star schema, KPIs listos\n4. Un Lakehouse por capa (o schemas separados)\n5. Bronze nunca se transforma destructivamente\n6. Silver usa MERGE para idempotencia\n7. Gold alimenta modelos semánticos Direct Lake" },

    // ─── Licenciamiento y SKUs (93-98) ───
    { id: 93, domain: 2, front: "F-SKUs de Fabric", back: "**F2**: mínima, pruebas/dev. **F64**: equivalente a P1 (Premium). **F128**: P2. **F256**: P3. Escala hasta F2048. Cada SKU define CU (Capacity Units) disponibles. Se paga por hora en Azure. Trial = F64 durante 60 días." },
    { id: 94, domain: 2, front: "Capacity Units (CU) y throttling", back: "Las operaciones consumen CU. Si el consumo excede los CU de la SKU, Fabric aplica **throttling** (ralentiza operaciones) o las encola. **Smoothing**: promedia el consumo en ventanas de tiempo. **Bursting**: permite picos temporales por encima del límite." },
    { id: 95, domain: 2, front: "Features por licencia: Pro vs Premium/Fabric", back: "**Pro**: publicar informes, compartir P2P, workspaces con menos de 10GB. **Premium/Fabric**: Deployment Pipelines, XMLA endpoint, Incremental Refresh avanzado, Direct Lake, paginación de informes, modelos >10GB, Dataflows Gen2, Pipelines." },
    { id: 96, domain: 2, front: "Workspace vs Capacity vs Tenant", back: "**Tenant**: organización completa (un OneLake). **Capacity**: recurso de computación asignado (F64, F128...), facturado. **Workspace**: contenedor lógico de items, asignado a una Capacity. Relación: Tenant → N Capacities → N Workspaces cada una." },
    { id: 97, domain: 2, front: "Capacity Metrics App", back: "Aplicación de Power BI para monitorizar el consumo de CU por: tipo de carga (Spark, SQL, Dataflows), workspace, item, y tiempo. Permite identificar operaciones costosas y optimizar el uso de la capacidad. Esencial para right-sizing." },
    { id: 98, domain: 2, front: "Autoscale en Fabric", back: "Permite añadir CU automáticamente cuando la demanda excede la capacidad base. Se configura con un tope máximo de CU adicionales. Evita throttling en picos de uso pero incrementa costes. Solo disponible en capacidades Azure (F-SKUs)." },

    // ─── Conceptos adicionales D1 (99-107) ───
    { id: 99, domain: 1, front: "Mirroring en Fabric", back: "Réplica continua de datos desde Azure SQL DB, Cosmos DB o Snowflake hacia OneLake en formato Delta. Los datos se mantienen sincronizados automáticamente sin necesidad de pipelines. Solo lectura en Fabric, escritura en el origen." },
    { id: 100, domain: 1, front: "Cross-database queries", back: "Consultar tablas de otros Lakehouses/Warehouses del mismo workspace sin mover datos: SELECT * FROM otro_lakehouse.dbo.tabla. Funciona en SQL endpoint y Warehouse. Para cross-workspace se necesitan shortcuts." },
    { id: 101, domain: 1, front: "Data Activator (Reflex)", back: "Componente de Real-Time Intelligence para crear alertas automáticas basadas en condiciones sobre datos de streaming. Ejemplo: enviar email si temperatura > 80°C. Sin código — visual. Conecta con Eventstream o Power BI visuals." },
    { id: 102, domain: 1, front: "Particionamiento en Delta Lake", back: "Dividir datos en subdirectorios por columna (PARTITIONED BY year, month). Mejora rendimiento de lectura cuando se filtra por la columna de partición. Evitar sobreparticionamiento (columnas de alta cardinalidad generan muchos archivos pequeños)." },
    { id: 103, domain: 1, front: "Schema enforcement vs Schema evolution", back: "**Enforcement** (default): rechaza escrituras que no coinciden con el schema existente. Protege la integridad. **Evolution**: permite añadir columnas automáticamente (option mergeSchema) o cambiar tipos. Se habilita explícitamente." },
    { id: 104, domain: 1, front: "Notebook Environments en Fabric", back: "Conjuntos reutilizables de configuración (librerías Python/R, jars, configuraciones Spark) que se asocian a un workspace. Garantizan reproducibilidad. Se crean desde la experiencia de Data Engineering y se asignan al ejecutar notebooks." },
    { id: 105, domain: 1, front: "Tipos de Shortcuts", back: "**OneLake**: entre items dentro de Fabric (Lakehouse a Lakehouse). **ADLS Gen2**: a cuentas de almacenamiento Azure. **Amazon S3**: a buckets S3. **Dataverse**: a tablas de Dataverse/Dynamics. Los datos NO se copian — solo referencia." },
    { id: 106, domain: 1, front: "Copy Activity vs Dataflow Gen2", back: "**Copy Activity**: mover datos binariamente (sin transformación o mínima) entre orígenes y destinos. Alto throughput. **Dataflow Gen2**: transformación visual completa con Power Query. Usar Copy para ingesta raw (Bronze), Dataflow para limpieza (Silver)." },
    { id: 107, domain: 1, front: "OneLake Data Hub", back: "Portal centralizado para descubrir y acceder a todos los datos en OneLake. Muestra items por workspace, tipo, endorsement. Permite crear shortcuts y explorar metadata sin navegar entre workspaces individualmente." },

    // ─── Conceptos adicionales D2 (108-115) ───
    { id: 108, domain: 2, front: "Unified Audit Log", back: "Registro centralizado de todas las acciones en el tenant: quién accedió a qué, cuándo, desde dónde. Incluye operaciones de Power BI, Fabric y Microsoft 365. Se consulta desde el Admin Portal o PowerShell (Search-UnifiedAuditLog)." },
    { id: 109, domain: 2, front: "Impact Analysis en Fabric", back: "Vista que muestra qué items se verían afectados si cambias un elemento. Ejemplo: si modifico esta tabla Delta, ¿qué modelos semánticos, informes y dashboards se ven impactados? Ayuda a evaluar riesgo de cambios." },
    { id: 110, domain: 2, front: "Data Lineage en Fabric", back: "Visualización del flujo de datos desde orígenes hasta informes: Origen → Pipeline/Dataflow → Lakehouse → Modelo Semántico → Informe. Disponible por workspace. Integración con Microsoft Purview para lineage cross-tenant." },
    { id: 111, domain: 2, front: "Tenant Settings (Admin Portal)", back: "Configuraciones a nivel de organización: habilitar/deshabilitar features (Git integration, export data, etc.), delegar a security groups, controlar quién puede crear workspaces, compartir externamente. Solo accesible por Fabric Admin." },
    { id: 112, domain: 2, front: "Disaster Recovery en Fabric", back: "**BCDR nativo**: OneLake tiene geo-redundancia (según la región). **Para items**: Git Integration como backup de definiciones. **Para datos**: shortcuts a ADLS como copia secundaria. Fabric no tiene un botón de DR — es un diseño de arquitectura." },
    { id: 113, domain: 2, front: "VNet Gateway vs On-premises Gateway", back: "**VNet Gateway (nuevo)**: conecta Fabric a recursos Azure dentro de una VNet por backbone privado. Sin necesidad de máquina gateway. **On-premises Gateway**: agente instalado en una máquina local para conectar a fuentes on-prem o VMs. Requiere mantenimiento." },
    { id: 114, domain: 2, front: "Trusted Workspace Access", back: "Permite que un workspace de Fabric acceda a recursos Azure protegidos por firewall (Azure Storage, SQL) sin abrir el firewall público. Se configura como identidad del workspace en las reglas de firewall del recurso Azure." },
    { id: 115, domain: 2, front: "Activity Log vs Monitoring Hub", back: "**Activity Log**: historial completo de ejecuciones pasadas, exportable, para auditoría. **Monitoring Hub**: vista en tiempo real de operaciones en curso (Spark jobs, pipeline runs, refreshes). Uno es histórico, otro es en vivo." },

    // ─── Conceptos adicionales D3 (116-125) ───
    { id: 116, domain: 3, front: "Calculation Groups: formato dinámico", back: "Cada calculation item puede incluir una **Format String Expression** que cambia el formato de la medida dinámicamente. Ejemplo: el item 'YoY %' puede cambiar el formato de moneda a porcentaje sin crear medidas separadas." },
    { id: 117, domain: 3, front: "Calculation Groups: precedencia", back: "Cuando múltiples Calculation Groups se aplican a la misma medida, la **precedencia** (número más alto = primero) define el orden de aplicación. Ejemplo: primero aplicar Time Intelligence (precedencia 20), luego Currency Conversion (precedencia 10)." },
    { id: 118, domain: 3, front: "Field Parameters", back: "Permiten que los usuarios de informes cambien dinámicamente qué campo (columna o medida) se muestra en un visual usando un slicer. Ejemplo: elegir entre ver Ventas, Margen o Unidades en el mismo gráfico." },
    { id: 119, domain: 3, front: "DirectQuery over Semantic Models", back: "Crear un modelo semántico que se conecta por DirectQuery a OTRO modelo semántico ya publicado. Permite: reutilizar modelos centralizados, añadir tablas locales, crear medidas específicas del departamento sin duplicar datos." },
    { id: 120, domain: 3, front: "TOM (Tabular Object Model)", back: "API .NET para gestionar modelos semánticos programáticamente. Crear/modificar tablas, medidas, relaciones, particiones vía código C#. Se conecta mediante XMLA endpoint. Usado en herramientas como ALM Toolkit y Tabular Editor." },
    { id: 121, domain: 3, front: "TMSL (Tabular Model Scripting Language)", back: "Scripts JSON para administrar modelos tabulares: createOrReplace, refresh, alter. Se ejecutan contra el XMLA endpoint desde SSMS, PowerShell o Azure DevOps. Útil para CI/CD de modelos semánticos." },
    { id: 122, domain: 3, front: "ALM Toolkit", back: "Herramienta gratuita para comparar y sincronizar modelos tabulares entre entornos. Muestra diferencias en medidas, tablas, relaciones. Permite promover cambios selectivamente. Complementa Deployment Pipelines para modelos complejos." },
    { id: 123, domain: 3, front: "Best Practices Analyzer (BPA)", back: "Reglas automatizadas en Tabular Editor que detectan anti-patrones: columnas no usadas, medidas sin formato, relaciones bidireccionales innecesarias, columnas de alta cardinalidad. Se ejecuta como linter del modelo semántico." },
    { id: 124, domain: 3, front: "Incremental Refresh: detect changes", back: "Optimización que evita refrescar particiones donde los datos no cambiaron. Usa una columna de marca de agua (LastModified). Solo refresca particiones donde max(LastModified) > valor anterior. Reduce carga en el origen." },
    { id: 125, domain: 3, front: "Direct Lake: guardrails por SKU", back: "Cada F-SKU tiene límites: **F64**: ~500M filas, 10GB. **F128**: ~1B filas, 20GB. **F256**: ~3B filas, 40GB. Si el modelo excede los guardrails, hace fallback permanente a DirectQuery. Hay guardrails de filas por tabla, columnas, y tamaño total." }
];
